#!/bin/bash

##############################################################################
# COFFEE: Unix utilities I use way too much
# https://github.com/markuskimius/coffee
#
# Copyright (c)2020 Mark K. Kim
# Released under the Apache license 2.0
# https://github.com/markuskimius/coffee/blob/master/LICENSE
##############################################################################

function usage() {
    cat <<EOF
Display the process tree of one or more processes.  All specified pid(s)'
ancestors and descendants are shown, but no siblings, in a tree format.  If
output to a terminal, the specified pid(s) are highlighted.

Usage: ${SCRIPTNAME} [-w] [-i] [-o COLUMNS] [PID or REGEX]

  PID                   Show this pid's tree.
  REGEX                 Show the pid tree of a process whose command matches REGEX.
                        REGEX never matches the current process.

  -w,--wide             Do not trim the output to the width of the terminal.
  -i,--ignore-case      Ignore case when matching REGEX.
  -o,--output COLUMNS   A comma-separated list of columns to add to the output.
                        Column names valid to 'ps -o' are accepted.  Width
                        control is accepted.

Examples:

  # Show all process in a tree format.
  ${SCRIPTNAME} 1

  # Show all bash and python processes in a tree format.
  ${SCRIPTNAME} bash python
  ${SCRIPTNAME} 'bash|python'

  # Show all processes in a tree format and highlight ssh and the root
  ${SCRIPTNAME} 1 ssh

EOF
}


##############################################################################
# PROGRAM BEGINS HERE

include "getopt.sh"

SCRIPTNAME=$(basename "${BASH_SOURCE}")
COLUMNS=( ppid pid:7 )
WIDEMODE=0

declare -A PS=()
PRINT_PIDS=()
PRINTED_PIDS=()
HILITE_PIDS=()


function main() {
    local OPTOPT OPTARG OPTERR OPTARRAY
    local exitcode=0
    local arg
    local pid

    # Process options
    while getopt-sh "hwio:" "help,wide,ignore-case,output:" "$@"; do
        case "$OPTOPT" in
            -h|--help)         usage && exit 0             ;;
            -w|--wide)         WIDEMODE=1                  ;;
            -i|--ignore-case)  shopt -s nocasematch        ;;
            -o|--output)       COLUMNS+=( ${OPTARG//,/ } ) ;;
            *)                 exitcode=1                  ;;
        esac
    done

    # Sanity check
    if (( exitcode )); then
        echo "Type '${SCRIPTNAME} -h' for help." 1>&2
        exit 1
    fi

    # Run ps once and memoize its output
    memoize_ps

    # Map the PIDs
    for arg in "${OPTARRAY[@]}"; do
        local pids=( $(arg_to_pids "$arg") )

        if (( ! ${#pids[@]} )); then
            echo "${arg}: no matching pid" 1>&2
            exitcode=1
            continue
        fi

        for pid in "${pids[@]}"; do
            HILITE_PIDS+=( "$pid" )
            PRINT_PIDS+=(
                $(ancestors_of "$pid")
                "$pid"
                $(descendants_of "$pid")
            )
        done
    done

    # Print the header
    if (( ${#PRINT_PIDS[@]} )); then
        print_pid "HEADER"
    fi

    # Print any PID yet to be printed
    for pid in ${PRINT_PIDS[@]}; do
        if [[ " ${PRINTED_PIDS[*]} " != *" $pid "* ]]; then
            pidtree "$pid" || exitcode=$?
        fi
    done

    return $exitcode
}


function memoize_ps() {
    local lastcol=${#COLUMNS[@]}
    local psline

    while read -r psline; do
        local psrow=( $psline )
        local ppid=${psrow[0]}
        local pid=${psrow[1]}
        local i

        # Header row's pid is "HEADER"
        if [[ "$pid" != +([0-9]) ]]; then
            pid="HEADER"
            ppid="HEADER"
        fi

        # Save the column values
        for (( i=1; i < $lastcol; i++ )); do
            PS[$pid|$i]=${psrow[$i]}
        done

        # Save meta data
        PS[$pid|ppid]=$ppid
        PS[$pid|command]=${psrow[*]:$lastcol}
        PS[$ppid|cpids]+=${PS[$ppid|cpids]+ }$pid
        PS[pids]+=${PS[pids]+ }$pid
    done < <(ps axww -o $(printf "%s," "${COLUMNS[@]}")command)
}


function arg_to_pids() {
    local arg=$1

    if [[ "$arg" == +([0-9]) ]]; then
        [[ " ${PS[pids]} " == *" $arg "* ]] && echo "$arg"
    else
        pid_match "$arg"
    fi
}


function pid_match() {
    local re=$1
    local pid

    for pid in ${PS[pids]}; do
        local cmd=${PS[$pid|command]}

        # Match $cmd but not if it's this process or one of its children
        if [[ "$cmd" =~ $re ]] && [[ "$$" != "$pid" ]] && [[ " ${PS[$$|cpids]} " != *" $pid "* ]]; then
            echo "$pid"
        fi
    done
}


function ancestors_of() {
    local pid=$1
    local ppid=${PS[$pid|ppid]}

    if (( "$ppid" )); then
        ancestors_of "$ppid"
        echo "$ppid"
    fi
}


function descendants_of() {
    local pid=$1
    local cpid

    for cpid in ${PS[$pid|cpids]}; do
        echo "$cpid"
        descendants_of "$cpid"
    done
}


function pidtree() {
    local pid=${1}
    local indent=${2-}
    local was_last=${3-0}
    local cpids=()
    local cpid

    # Print the PID at this node
    print_pid "$pid" "${indent}"

    # Get the subset of child pids is in $PRINT_PIDS
    for cpid in ${PS[$pid|cpids]}; do
        if [[ " ${PRINT_PIDS[*]} " == *" $cpid "* ]]; then
            cpids+=( "$cpid" )
        fi
    done

    # Traverse print-eligible children
    for cpid in "${cpids[@]}"; do
        local is_last=0

        # Calculate how child indentation should be drawn
        [[ "$cpid" == "${cpids[${#cpids[@]}-1]}" ]] && is_last=1

        # Visit the child pid
        if (( was_last )); then
            pidtree "$cpid" "${indent}    " $is_last    # no more siblings to draw
        else
            pidtree "$cpid" "${indent}|   " $is_last    # more siblings to draw beneath us
        fi
    done
}


function print_pid() {
    local pid=$1
    local indent="${2-}+-- "
    local color=""
    local plain=""
    local output=""
    local i

    # Build the output string
    for (( i=1; i < ${#COLUMNS[@]}; i++ )); do
        local width=${COLUMNS[$i]#*:}

        [[ "$width" != +([0-9]) ]] && width=7

        output+=$(printf "%*s " "$width" "${PS[$pid|$i]}")
    done
    output+=" ${indent:4}${PS[$pid|command]}"

    # Shorten the output to terminal if not in wide mode
    if [[ -t 1 ]] && (( ! WIDEMODE )); then
        local termwidth=$(termwidth)

        output=${output:0:$termwidth}
    fi

    # Colorize if outputting to a terminal
    if [[ -t 1 ]] && [[ " ${HILITE_PIDS[*]} " == *" $pid "* ]]; then
        color=$'\e[1;31m'
        plain=$'\e[0m'
    fi

    # Output
    echo "${color}${output}${plain}"
    PRINTED_PIDS+=( "$pid" )
}


function termwidth() {
    (( ! "$COLUMNS" )) && COLUMNS=$(tput cols 2>/dev/null)
    (( ! "$COLUMNS" )) && COLUMNS=128

    echo "$COLUMNS"
}


##############################################################################
# ENTRY POINT

main "$@"
